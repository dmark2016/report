\section{Results and Discussion}
\label{sec:results-and-discussion}
% \subsection{Description}
% This section presents the results of your experiments,
% comparing your solution to other schemes. The metrics of
% interest are highly dependent on the topic of research, but
% should optimally cover all interesting aspects of your scheme.
% Informative graphs or tables are the key to a good result
% section.
% Furthermore, you need to discuss your results. You should
% give explanations of distinctive points and outliers in your
% results. It is also necessary to state why your scheme is
% better/worse compared to the other schemes. Thus, this section
% consists of two parts: the results of your experiments, as well
% as an explanation as to why the results are as they are

Figure \ref{fig:comparison} shows how the various prefetchers compare in terms of average speedup.
SDP, RPT and DC all perform fairly evenly.
This is to be expected, as they are all variations around the same idea.
We see that our hybrid prefetcher has lower average speedup than the simple DC implementation.
By comparing the results in greater detail, we try to understand why.

\begin{figure*}
  \centering
  \includegraphics{plots/overview_speedup.pdf}
  \caption{Speedup for each prefetcher for all benchmarks and harmonic mean average speedup.}
  \label{fig:comparison}
\end{figure*}


An interesting example of how the different prefetchers differ, is the \texttt{ammp} benchmark.
This is the benchmark where the sequential prefetcher performs worst;
it degrades performance significantly and a higher prefetching degree only makes
it worse.
For degree 1, it identifies just above $3.5m$ possible prefetches, but an
extremely low accuracy of only $0.1\%$ means most of the effort put into
prefetching blocks is wasted.

The SDP prefetcher on the other hand performs quite well and gives a speedup of
$1.7$ for a prefetching degree of $3$.
For this degree, the number of identified prefetches is around $8.4m$, but an
accuracy of $86\%$ means only $1.2m$ of these are wasted effort.
As the only difference between this and the sequential prefetcher is the
variable stride used for SDP, this indicates that the \texttt{ammp} benchmark
accesses memory in a linear, but strided fashion.
\todo{Is this consistent with the benchmark description?}

The remaining prefetchers all handle strided access and results comparable with
SDP should therefore be expected.
For delta correlation, the best results are achieved with a prefetching degree of $6$.
At this degree, this results in $14m$ prefetches being identified, where $84\%$
or around $12m$ turns out to be useful.
The $2.3m$ fetches for useless data is probably what makes delta correlation
less effective than SDP despite the improved coverage.
%TODO: Comment how many of these were already in MSHRs?
This is also suggested by the $44\%$ increase in average cache miss latency.

For the hybrid prefetcher developed during this project, the speedup on \texttt{ammp} is slightly
worse than for the pure delta correlation approach.
Despite falling back to RPT and eventually SDP, the hybrid approach identifies
fewer prefetches than the delta correlating prefetcher.
Combined with about the same accuracy as for delta correlation, this can explain
the reduced performance.
\todo{Why?}

// TODO: Write more in depth analysis that explore why the hybrid prefetcher performs worse than DC.


%The best average speedup is $1.0$ for a degree of 1.
%We observe that different benchmarks respond differently to different degrees of prefetching.
%See Figure \ref{fig:sequential}
%\texttt{applu},
%
%
%\begin{figure}
%  \input{plots/sequential.tex}
%  \caption{Effect of prefetching degree in sequential prefetcher for benchmarks.}
%  \label{fig:sequential}
%\end{figure}
%
%%\begin{figure*}
%%  \input{plots/seq3.tex}
%%  \caption{Performance of sequential prefetcher with $p = 3$ across benchmarks.}
%%  \label{fig:seq3}
%%\end{figure*}
%
%\subsubsection{Stride Direct Prefetcher}
%A simple implementation of a stride direct prefetcher yielded a better average speedup ($1.07$) than the sequential prefetcher.
%The benchmarks wupwise and ammp had high speedups, which pulled up the average.
%This prefetcher had a negative impact on the twolf benchmark.
%
%
%\subsubsection{Reference Prediction Table}
%// TODO: 
%The RPT implementation yielded an average speedup of $1.06$.
%While slightly lower than the SDP average, the maximum and minimum values are closer together.
%Testing of the RPT implementation saw no benchmark with a speedup of less than $0.95$.
%Figure~\ref{fig:rpt} shows how RPT performs on each benchmark.
%
%%\begin{figure*}
%%  \input{plots/rpt.tex}
%%  \caption{Performance of RPT prefetcher across benchmarks.}
%%  \label{fig:rpt}
%%\end{figure*}
%
%\subsubsection{Global History Buffer with Delta Correlation}
%The implementation of the global history buffer with SDP and RTP as fallback was successfully implemented and yielded the speedups shown in Figure \ref{fig:ghbdc}.
%The best speedup was acquired for the ammp benchmark, but many of the other benchmark showed only a slight speedup if any at all.
%
%
%\begin{figure*}
%  \input{plots/ghbdc.tex}
%  \caption{Speedup of each benchmark as a function of degree for the global history buffer with delta correlation and fall back to SDP and RTP.}
%  \label{fig:ghbdc}
%\end{figure*}
%
%\begin{figure*}
%  \input{plots/ghbdcavg.tex}
%  \caption{Average speedup as a function of prefetching degree for our final prefetcher implementation.}
%  \label{fig:ghbdcavg}
%\end{figure*}
%
%%\subsection{Description}
%% This section might elaborate on alternative approaches that
%% you have tried, but were not successful. It discusses weaknesses
%% of your scheme and highlights the strong and weak
%% points of your experimental setup.
%
%Experimenting with sequential prefetching of various degrees yielded surprisingly good results for some benchmarks.
%A possible explanation for this is that the benchmark's behavior matched exceptionally well with the assumptions used when creating the prefetcher.
%Based on this, it is reasonable to assume that the \texttt{applu} and \texttt{wupwise} benchmarks access memory fairly sequentially.
%
%\todo{SDP}
%\todo{RPT}
%
%Our hybrid implementation
%More interesting to note, is that the delta-correlation implementation does an exceptionally good job at the \texttt{ammp} benchmark.
%This was the benchmark with the highest negative performance impact from the naive sequential prefetcher, but the memory pattern seems to be very well suited for delta correlation.
