\section{Methodology}
\label{sec:methodology}
% \subsection{Description}
% The methodology section explains your experimental setup.
% It should state every bit of information that is necessary in
% order to be able to reproduce your results. It further covers
% your actions taken in order to ensure that you are really
% measuring what you think you are measuring as well as your
% actions that were taken in order to validate your results. The
% goals are to set up realistic experiments and be absolutely
% convinced that you took care of all side-effects as well as to
% state enough information such that your experiments are fully
% reproducible.

\subsection{Simulated Architecture}

We use the M5 computer architecture simulator~\cite{bib:m5} to evaluate different prefetching techniques.
The simulated architecture is that of the Alpha 21264\cite{bib:alpha-21264}, a superscalar, out-of-order CPU.
The simulator is configured with a two level cache system; level 1 is a split cache with 32 kB for instructions and 64 kB for data, level 2 a combined cache of 1 MB.
Access to main memory takes $30$ns over a $64$ bit memory bus clocked at $400$ MHz.

We implement a prefetcher as a set of C++ functions specified by the memory interface of the simulator~\cite[Section 3.2]{bib:doc}.
\texttt{prefetch\_init()}, which is called when the simulation starts, allows us to initialize data structures.
\texttt{prefetch\_access()} is called every time the L2 cache is accessed.
Here, we decide if and what we should prefetch.

The prefetcher is compiled into the simulator before running benchmarks to evaluate its performance.

\subsection{Benchmarking}

The SPEC CPU2000\cite{bib:cpu2000} is a suite of benchmark programs designed to test hardware performance.
To evaluate prefetcher performance, we use a subset of the programs available in the suite.
They are as follows; \texttt{bzip2}, a compression algorithm, \texttt{twolf},
a place-and-route package used in microchip design, \texttt{wupwise}, a solver for a set of
equations in the field of quantum chromodynamics, \texttt{swim} a weather prediction program,
\texttt{applu} and \texttt{ammp}, differential equation solvers, \texttt{galgel}, a solver for a
particular problem in fluid dynamics and \texttt{apsi}, a program used to predict spread of air pollution.

The goal we set for our prefetcher was to achieve as high average speedup as we could, while having no individual benchmark with a speedup of less than $0.95$.
A prefetcher with a negative impact greater than that on one or more types of programs, would be infeasible to use in a real world scenario.
In order to determine whether the goal had been reached, a method of evaluating the developed prefetchers was required.
During this project, the evaluation was done using the M5 computer architecture simulator running a reduced SPEC CPU2000 benchmark suite compiled for an ALPHA architecture.
The simulator was configured with a two level cache system; level 1 was a split cache with 32 kB for instructions and 64 kB for data, level 2 a combined cache of 1 MB.
The prefetchers were implemented in C and compiled into the simulator before running the benchmarks.

After running the benchmarks, the simulator output the speedup, accuracy and coverage the prefetcher had for every benchmark, as well as the number of prefetches identified,
number of prefetches issued and the total number of L2 cache misses for each benchmark. In addition the average speedup (calculated by harmonic mean) of all the benchmarks
was output. We used the average speedup and to some extent the speedup for each benchmark to judge and compare the prefetchers.

Several classical prefetchers were implemented, tested and evaluated to provide a solid starting point.
The implemented prefetchers were a sequential prefetcher, SDP, RPT, and a GHB with delta correlation.

Next, the GHB implementation was extended to also include RTP and ultimately SPD as fall backs whenever the delta correlation did not result in any prefetches being performed.

When testing each prefetcher, the relevant aggressiveness was adjusted (within reasonable limits) for best average speedup.

\subsection{SPEC CPU2000}
CPU2000 was designed to provide a way to measure performance across
a wide range of hardware. The benchmarks are based on real user
applications. They measure the performance of the processor, memory
and the compiler. CPU2000 contains 25 different benchmarks and
measures both integer and floating point performance.

\cite{bib:cpu2000}

\subsection{M5 simulator}
M5 is an open-source hardware simulation system. It supports multiple
different CPU architectures, one of them being Alpha, which we used.
It has an event-driven memory system which among other features supports
flexible arrangements of the components so it is possible to model
multilevel caches. M5 uses a trace-based CPU model to achieve fast and
accurate measuring of the performance of the memory system.

\cite{bib:m5}
