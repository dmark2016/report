\section{Methodology}
\label{sec:methodology}
% \subsection{Description}
% The methodology section explains your experimental setup.
% It should state every bit of information that is necessary in
% order to be able to reproduce your results. It further covers
% your actions taken in order to ensure that you are really
% measuring what you think you are measuring as well as your
% actions that were taken in order to validate your results. The
% goals are to set up realistic experiments and be absolutely
% convinced that you took care of all side-effects as well as to
% state enough information such that your experiments are fully
% reproducible.

The goal we set for our prefetcher was to achieve as high average speedup as we could, while having no individual benchmark with a speedup of less than $0.95$.
A prefetcher with a negative impact greater than that on one or more types of programs, would be infeasible to use in a real world scenario.
In order to determine whether the goal had been reached, a method of evaluating the developed prefetchers was required.
During this project, the evaluation was done using the M5 computer architecture simulator running a reduced SPEC CPU2000 benchmark suite compiled for an ALPHA architecture.
The simulator was configured with a two level cache system; level 1 was a split cache with 32 kB for instructions and 64 kB for data, level 2 a combined cache of 1 MB.
The prefetchers were implemented in C and compiled into the simulator before running the benchmarks.

After running the benchmarks, the simulator output the speedup, accuracy and coverage the prefetcher had for every benchmark, as well as the number of prefetches identified,
number of prefetches issued and the total number of L2 cache misses for each benchmark. In addition the average speedup (calculated by harmonic mean) of all the benchmarks
was output. We used the average speedup and to some extent the speedup for each benchmark to judge and compare the prefetchers.

Several classical prefetchers were implemented, tested and evaluated to provide a solid starting point.
The implemented prefetchers were a sequential prefetcher, SDP, RPT, and a GHB with delta correlation.

Next, the GHB implementation was extended to also include RTP and ultimately SPD as fall backs whenever the delta correlation did not result in any prefetches being performed.

When testing each prefetcher, the relevant aggressiveness was adjusted (within reasonable limits) for best average speedup.
